package crux.ast;

import crux.ast.*;
import crux.ast.OpExpr.Operation;
import crux.pt.CruxBaseVisitor;
import crux.pt.CruxParser;
import crux.ast.types.*;
import crux.ast.SymbolTable.Symbol;
import org.antlr.v4.runtime.ParserRuleContext;

import java.io.PrintStream;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * This class will convert the parse tree generated by ANTLR to AST It follows the visitor pattern
 * where decls will be by DeclVisitor Class Stmts will be resolved by StmtVisitor Class Exprs will
 * be resolved by ExprVisitor Class
 */

public final class ParseTreeLower {
  private final DeclVisitor declVisitor = new DeclVisitor();
  private final StmtVisitor stmtVisitor = new StmtVisitor();
  private final ExprVisitor exprVisitor = new ExprVisitor();

  private final SymbolTable symTab;

  public ParseTreeLower(PrintStream err) {
    symTab = new SymbolTable(err);
  }

  private static Position makePosition(ParserRuleContext ctx) {
    var start = ctx.start;
    return new Position(start.getLine());
  }

  /**
   * @return True if any errors
   */
  public boolean hasEncounteredError() {
    return symTab.hasEncounteredError();
  }

  /**
   * Lower top-level parse tree to AST
   * @return a {@link DeclarationList} object representing the top-level AST.
   */
  public DeclarationList lower(CruxParser.ProgramContext program) {
    Position pos = makePosition(program);
    List<Declaration> decls = new ArrayList<>();
    for (CruxParser.DeclContext declContext : program.declList().decl()) {
      Declaration decla = declContext.accept(declVisitor);

      decls.add(decla);
    }
    return new DeclarationList(pos, decls);
  }

  /**
   * Lower stmt list by lower individual stmt into AST.
   * @return a {@link StatementList} AST object.
   */

  private StatementList lower(CruxParser.StmtListContext stmtList) {
    Position pos = makePosition(stmtList);
    List<Statement> sl = new ArrayList<>();
    for (CruxParser.StmtContext stmtCtx : stmtList.stmt()) {
      Statement stmt = stmtCtx.accept(stmtVisitor);
      sl.add(stmt);
    }
    return new StatementList(pos, sl);
  }

  /**
   * Similar to {@link #lower(CruxParser.StmtListContext)}, but handles symbol table as well.
   * @return a {@link StatementList} AST object.
   */
  private StatementList lower(CruxParser.StmtBlockContext stmtBlock) {
    symTab.enter();
    StatementList test = lower(stmtBlock.stmtList());
    symTab.exit();
    return test;
  }

  /**
   * A parse tree visitor to create AST nodes derived from {@link Declaration}
   */
  private final class DeclVisitor extends CruxBaseVisitor<Declaration> {
    /**
     * Visit a parse tree var decl and create an AST {@link VariableDeclaration}
     * @return an AST {@link VariableDeclaration}
     */
     public VariableDeclaration visitVarDecl(CruxParser.VarDeclContext ctx) {
       String varName = ctx.Identifier().getText();
       Position pos = makePosition(ctx);
       var argTypeList = new TypeList();
       Type type = null;
       if(ctx.type().getText().equals("int")){type = new IntType(); argTypeList.append(new IntType());}
       else if (ctx.type().getText().equals("bool")){type = new BoolType(); argTypeList.append(new BoolType());}
       else if (ctx.type().getText().equals("void")){type = new VoidType(); argTypeList.append(new VoidType());}
       Symbol symbol = symTab.add(pos, varName, type);
       return new VariableDeclaration(pos, symbol);
     }

    /**
     * Visit a parse tree array decl and creates an AST {@link ArrayDeclaration}
     * @return an AST {@link ArrayDeclaration}
     */
    public Declaration visitArrayDecl(CruxParser.ArrayDeclContext ctx) {

      String arrayName = ctx.Identifier().getText();
      Position pos = makePosition(ctx);
      var argTypeList = new TypeList();
      Type type = null;
      String intt = ctx.Integer().getText();
      int num_of_array = Integer.parseInt(intt);
      if(ctx.type().getText().equals("int")){type = new ArrayType(num_of_array, new IntType()); argTypeList.append(new IntType());}
      else if (ctx.type().getText().equals("bool")){type = new ArrayType(num_of_array, new BoolType()); argTypeList.append(new BoolType());}

      else if (ctx.type().getText().equals("void")){type = new VoidType(); argTypeList.append(new VoidType());}
      Symbol symbol = symTab.add(pos, arrayName, type);

      return new ArrayDeclaration(pos, symbol);
    }

    /**
     * Visit a parse tree function definition and create an AST {@link FunctionDefinition}
     * @return an AST {@link FunctionDefinition}
     */
    public Declaration visitFunctionDefn(CruxParser.FunctionDefnContext ctx) {
      Position pos = makePosition(ctx);
      String name = ctx.Identifier().getText();
      var argList = new TypeList();
      List<Symbol> params = new ArrayList<>();

      for ( var paramCtx : ctx.paramList().param()){
        String currParam = paramCtx.Identifier().getText();
        Type type = null;

        String string = paramCtx.type().getText();
        switch (string) {
          case "int":
            type = new IntType();
            argList.append(type);
            break;
          case "bool":
            type = new BoolType();
            argList.append(type);
            break;
          case "void":
            type = new VoidType();
            argList.append(type);
            break;
          default:
        }
      }

      Type returnType = null;
      String string = ctx.type().getText();
      switch (string) {
        case "int":
          returnType = new IntType();
          break;
        case "bool":
          returnType = new BoolType();
          break;
        case "void":
          returnType = new VoidType();
          break;
        default:
      }

      Symbol functionSymbol = symTab.add(makePosition(ctx), name, new FuncType(argList, returnType));
      symTab.enter();

      for ( var paramCtx : ctx.paramList().param()){
        String currType = paramCtx.type().getText();
        String currParam = paramCtx.Identifier().getText();
        Type type = null;
        switch (currType) {
          case "int":
            type = new IntType();
            break;
          case "bool":
            type = new BoolType();
            break;
          case "void":
            type = new VoidType();
            break;
          default:
            type = new BoolType();
        }
        Symbol paramSymbol = symTab.add(makePosition(paramCtx), currParam, type);
        params.add(paramSymbol);
      }

      StatementList functionBody = lower(ctx.stmtBlock().stmtList());
      symTab.exit();

      return new FunctionDefinition(pos, functionSymbol, params, functionBody);
    }
  }
  /**
   * A parse tree visitor to create AST nodes derived from {@link Statement}
   */

  private final class StmtVisitor extends CruxBaseVisitor<Statement> {
    /**
     * Visit a parse tree var decl and create an AST {@link VariableDeclaration}. Since
     * {@link VariableDeclaration} is both {@link Declaration} and {@link Statement}, we simply
     * delegate this to {@link DeclVisitor#visitArrayDecl(CruxParser.ArrayDeclContext)} which we
     * implement earlier.
     * @return an AST {@link VariableDeclaration}
     */

     public Statement visitVarDecl(CruxParser.VarDeclContext ctx) {
       return declVisitor.visitVarDecl(ctx);
     }

    /**
     * Visit a parse tree assignment stmt and create an AST {@link Assignment}
     * @return an AST {@link Assignment}
     */

    public Statement visitAssignStmt(CruxParser.AssignStmtContext ctx) {
      Expression lhs = ctx.designator().accept(exprVisitor);
      Expression rhs = ctx.expr0().accept(exprVisitor);
      if (lhs == null || rhs == null) {
        throw new RuntimeException("LHS or RHS of an assignment is null");
      }
      Position pos = makePosition(ctx);
      return new Assignment(pos, lhs, rhs);
    }

    /**
     * Visit a parse tree call stmt and create an AST {@link Call}. Since {@link Call} is both
     * {@link Expression} and {@link Statement}, we simply delegate this to
     * {@link ExprVisitor#visitCallExpr(CruxParser.CallExprContext)} that we will implement later.
     * @return an AST {@link Call}
     */
    public Statement visitCallStmt(CruxParser.CallStmtContext ctx) {
      return exprVisitor.visitCallExpr(ctx.callExpr());
    }


    /**
     * Visit a parse tree if-else branch and create an AST {@link IfElseBranch}. The template code
     * shows partial implementations that visit the then block and else block recursively before
     * using those returned AST nodes to construct {@link IfElseBranch} object.
     * @return an AST {@link IfElseBranch}
     */

    public Statement visitIfStmt(CruxParser.IfStmtContext ctx) {
      Position pos = makePosition(ctx);
      Expression cond = ctx.expr0().accept(exprVisitor);
      StatementList thenBlock = new StatementList(pos, new ArrayList<>());
      StatementList elseBlock = new StatementList(pos, new ArrayList<>());
      if (ctx.stmtBlock(0) != null){
        thenBlock = lower(ctx.stmtBlock(0));
        if (ctx.stmtBlock(1) != null){
          elseBlock = lower(ctx.stmtBlock(1));
        }
      }
      return new IfElseBranch(pos, cond, thenBlock, elseBlock);
    }


    /**
     * Visit a parse tree for loop and create an AST {@link Loop}. You'll going to use a similar
     * techniques as {@link #visitIfStmt(CruxParser.IfStmtContext)} to decompose this construction.
     *
     * @return an AST {@link Loop}
     */
    public Statement visitLoopStmt(CruxParser.LoopStmtContext ctx) {
      Position pos = makePosition(ctx);
      StatementList SL = null;
      if (ctx.stmtBlock() != null){
        SL = lower(ctx.stmtBlock().stmtList());
      }
      return new Loop(pos, SL);
    }


    /**
     * Visit a parse tree return stmt and create an AST {@link Return}. Here we show a simple
     * example of how to lower a simple parse tree construction.
     * @return an AST {@link Return}
     */
    public Statement visitReturnStmt(CruxParser.ReturnStmtContext ctx) {
      Position pos = makePosition(ctx);
      Expression exp = ctx.expr0().accept(exprVisitor);
      return new Return(pos, exp);
    }

    /**
     * Creates a Break node
     */
    public Statement visitBreakStmt(CruxParser.BreakStmtContext ctx) {
      Position pos = makePosition(ctx);
      return new Break(pos);
    }

    /**
     * Creates a Continue node
     */
    public Statement visitContinueStmt(CruxParser.ContinueStmtContext ctx) {
      Position pos = makePosition(ctx);
      return new Continue(pos);
    }
  }

  private final class ExprVisitor extends CruxBaseVisitor<Expression> {
    /**
     * Parse Expr0 to OpExpr Node Parsing the expr should be exactly as described in the grammer
     */
    public Expression visitExpr0(CruxParser.Expr0Context ctx) {
      var left = ctx.expr1(0).accept(exprVisitor);
      Position pos = makePosition(ctx);
      Operation op;

      if (ctx.op0() != null) {
        var right = ctx.expr1(1).accept(exprVisitor);
        CruxParser.Op0Context op0 = ctx.op0();
        String opStr = ctx.op0().getText();
        switch (opStr) {
          case ">=":
            op = Operation.GE;
            break;
          case "<=":
            op = Operation.LE;
            break;
          case "!=":
            op = Operation.NE;
            break;
          case "==":
            op = Operation.EQ;
            break;
          case ">":
            op = Operation.GT;
            break;
          default:
            op = Operation.LT;
            break;
        }
        return new OpExpr(pos, op, left, right);
      }
      else {
        return left;
      }
    }

    /**
     * Parse Expr1 to OpExpr Node Parsing the expr should be exactly as described in the grammer
     */
    public Expression visitExpr1(CruxParser.Expr1Context ctx) {
      if (ctx.op1() == null) {
        return ctx.expr2().accept(exprVisitor);
      }
      var left = ctx.expr1().accept(exprVisitor);
      var right = ctx.expr2().accept(exprVisitor);
      Position pos = makePosition(ctx);
      Operation op;
      String opStr = ctx.op1().getText();

      switch (opStr) {
        case "+":
          op = Operation.ADD;
          break;
        case "-":
          op = Operation.SUB;
          break;
        default:
          op = Operation.LOGIC_OR;
          break;
      }
      return new OpExpr(pos, op, left, right);
    }

    /**
     * Parse Expr2 to OpExpr Node Parsing the expr should be exactly as described in the grammer
     */
    public Expression visitExpr2(CruxParser.Expr2Context ctx) {
      Position pos = makePosition(ctx);
      if (ctx.op2() == null) {
        return ctx.expr3().accept(exprVisitor);
      }
      Expression left = ctx.expr2().accept(exprVisitor);
      Expression right = ctx.expr3().accept(exprVisitor);
      CruxParser.Op2Context op2 = ctx.op2();
      Operation op;
      String opStr = ctx.op2().getText();

      switch (opStr) {
        case "*":
          op = Operation.MULT;
          break;
        case "/":
          op = Operation.DIV;
          break;
        default:
          op = Operation.LOGIC_AND;
          break;
      }
      return new OpExpr(pos, op, left, right);
    }


    /**
     * Parse Expr3 to OpExpr Node Parsing the expr should be exactly as described in the grammer
     */
    public Expression visitExpr3(CruxParser.Expr3Context ctx) {
      Position pos = makePosition(ctx);
      if (ctx.expr3() != null) {
        Operation op = Operation.LOGIC_NOT;;
        Expression left = ctx.expr3().accept(exprVisitor);
        return new OpExpr(pos, op, left, null);
      }
      else if (ctx.expr0() != null) {
        return ctx.expr0().accept(exprVisitor);
      }
      else if (ctx.designator() != null) {
        return ctx.designator().accept(exprVisitor);
      }
      else if (ctx.callExpr() != null) {
        return ctx.callExpr().accept(exprVisitor);
      }
      else {
        return ctx.literal().accept(exprVisitor);
      }
    }

    /**
     * Create Call Node
     */
    public Call visitCallExpr(CruxParser.CallExprContext ctx) {
      String name = ctx.Identifier().getText();
      Position pos = makePosition(ctx);
      Symbol symbol = symTab.lookup(pos, name);

      List<Expression> arguments = new ArrayList<>();
      if (ctx.exprList() != null) {
        List<CruxParser.Expr0Context> exprs = ctx.exprList().expr0();
        for (CruxParser.Expr0Context exprCtx : exprs) {
          Expression argument = exprCtx.accept(this);
          arguments.add(argument);
        }
      }
      return new Call(pos, symbol, arguments);
    }


    /**
     * visitDesignator will check for a name or ArrayAccess FYI it should account for the case when
     * the designator was dereferenced
     */
    public Expression visitDesignator(CruxParser.DesignatorContext ctx) {
      String name = ctx.Identifier().getText();
      Position pos = makePosition(ctx);
      Symbol symbol = symTab.lookup(pos, name);
      if (ctx.expr0() !=null){
        return new ArrayAccess(pos, symbol, ctx.expr0().accept(exprVisitor));
      }
      else {return new VarAccess(pos, symbol);}
    }

    /**
     * Create an Literal Node
     */
    public Expression visitLiteral(CruxParser.LiteralContext ctx) {
      if (ctx.Integer() != null) {
        String number = ctx.Integer().getText();
        int value = Integer.parseInt(number);
        Position pos = makePosition(ctx);
        return new LiteralInt(pos, value);  // Assuming there is an IntLiteral class for integer literals
      }
      // Check if the context contains the True literal
      else if (ctx.True() != null) {
        Position pos = makePosition(ctx);
        return new LiteralBool(pos, true);
      }
      // Check if the context contains the False literal
      else { // (ctx.False() != null)
        Position pos = makePosition(ctx);
        return new LiteralBool(pos, false);  // Assuming there is a BoolLiteral class for boolean literals
      }
    }
  }
}
